<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>五目並べ</title>
<style>
  body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin-top: 30px; }
  #rooms { display: flex; gap: 20px; margin-bottom: 20px; }
  .room { border: 1px solid #333; padding: 10px; width: 160px; text-align: center; }
  #board { display: grid; grid-template-columns: repeat(15, 30px); grid-template-rows: repeat(15, 30px); gap: 0; margin-top: 10px; }
  .cell {
    width: 30px; height: 30px; background: #f0d9b5;
    display:flex; align-items:center; justify-content:center;
    border: 1px solid #000; box-sizing: border-box;
    cursor: pointer; user-select: none;
  }
  .cell.disabled { cursor: not-allowed; opacity: .6; }
  .stone { width: 80%; height: 80%; border-radius: 50%; display: block; }
  .stone.black { background: #000; }
  .stone.white { background: #fff; box-shadow: inset 0 0 0 1px #000; }
  #message { margin-top: 12px; min-height: 1.6em; }
  #controls { margin-top: 10px; display: none; gap: 8px; }
  button { padding: 6px 10px; border: 1px solid #ccc; border-radius: 6px; background: #fff; cursor: pointer; }
  .cell { position: relative; }              /* 擬似要素でリングを出すため */
  .cell.last::after {
    content: "";
    position: absolute;
    inset: 4px;                              /* リングの余白（好みで調整可） */
    border: 2px solid #ff3b30;               /* 赤いリング（好みで色/太さ調整可） */
    border-radius: 50%;
    pointer-events: none;                    /* クリック判定に影響しない */
  }
</style>
</head>
<body>

<h2>ルーム選択</h2>
<div id="rooms"></div>

<div id="game" style="display:none">
  <div id="message"></div>
  <div id="board"></div>
  <div id="controls"></div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
const socket = io();

const roomsEl = document.getElementById('rooms');
const gameEl = document.getElementById('game');
const boardEl = document.getElementById('board');
const messageEl = document.getElementById('message');
const controlsEl = document.getElementById('controls');

const SIZE = 15;
let myTurn = false;
let myColor = null;   // 'black'|'white'
let oppColor = null;
let awaitingAck = false;
let board = Array.from({length: SIZE}, () => Array(SIZE).fill(null));

// ===== 共通UI：状況に応じて毎回作り直す =====
function renderControlsInRoom() {
  controlsEl.innerHTML = '';
  const leaveBtn = document.createElement('button');
  leaveBtn.textContent = '退出';
  leaveBtn.onclick = () => {
    socket.emit('exitGame');
    clearBoardUI();
    messageEl.textContent = '退出しました';
    renderControlsBackToLobby();
  };
  controlsEl.appendChild(leaveBtn);
  controlsEl.style.display = 'flex';
}

function renderControlsPostGame() {
  controlsEl.innerHTML = '';
  const rematchBtn = document.createElement('button');
  rematchBtn.textContent = '再戦リクエスト';
  rematchBtn.onclick = () => {
    socket.emit('rematchRequest');
    messageEl.textContent = '再戦リクエスト送信…相手を待っています';
    rematchBtn.disabled = true;
  };
  const leaveBtn = document.createElement('button');
  leaveBtn.textContent = '退出';
  leaveBtn.onclick = () => {
    socket.emit('exitGame');
    messageEl.textContent = '退出しました';
    renderControlsBackToLobby();
  };
  controlsEl.appendChild(rematchBtn);
  controlsEl.appendChild(leaveBtn);
  controlsEl.style.display = 'flex';
}

function renderControlsBackToLobby() {
  controlsEl.innerHTML = '';
  const backBtn = document.createElement('button');
  backBtn.textContent = 'ルーム選択に戻る';
  backBtn.onclick = () => {
    socket.emit('returnToLobby');
    gameEl.style.display = 'none';
    roomsEl.style.display = 'flex';
    controlsEl.style.display = 'none';
    messageEl.textContent = '';
  };
  controlsEl.appendChild(backBtn);
  controlsEl.style.display = 'flex';
}

// ===== ルーム一覧 =====
function renderRooms(rooms) {
  roomsEl.innerHTML = '';
  rooms.forEach(r => {
    const label = r.state === 'empty' ? '空き'
                : r.state === 'waiting' ? '相手待機中'
                : '試合中';
    const disabled = r.state === 'playing' ? 'disabled' : '';

    const div = document.createElement('div');
    div.className = 'room';
    div.innerHTML = `
      <div><strong>ルーム${r.id}</strong></div>
      <div style="margin:6px 0">${label}</div>
      <button ${disabled} onclick="joinRoom(${r.id})">入室</button>
    `;
    roomsEl.appendChild(div);
  });
}
window.joinRoom = (id) => socket.emit('joinRoom', id);

// ===== 盤面 =====
function initBoard(){
  board = Array.from({length: SIZE}, () => Array(SIZE).fill(null));
  awaitingAck = false;
  boardEl.innerHTML = '';
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.x = x;
      cell.dataset.y = y;
      cell.addEventListener('click', () => tryPlace(x, y));
      boardEl.appendChild(cell);
    }
  }
  renderBoard();
  refreshInteractivity();
}

function renderBoard(){
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      const cell = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
      while (cell.firstChild) cell.removeChild(cell.firstChild);
      const v = board[y][x];
      if (v) {
        const s = document.createElement('span');
        s.className = `stone ${v}`;
        cell.appendChild(s);
      }
    }
  }
}

function refreshInteractivity(){
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      const cell = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
      if (!myTurn || board[y][x] || awaitingAck) cell.classList.add('disabled');
      else cell.classList.remove('disabled');
    }
  }
}

function tryPlace(x, y){
  if (!myTurn || awaitingAck || board[y][x]) return;
  // サーバー承認前に描画しない（同期ずれ防止）
  awaitingAck = true;
  refreshInteractivity();
  socket.emit('play', { x, y });
}

function clearBoardUI() {
  boardEl.innerHTML = '';
}

// ===== ソケットイベント =====
socket.on('updateRooms', renderRooms);
socket.on('roomFull', () => alert('試合中です'));

socket.on('waitingOpponent', () => {
  roomsEl.style.display = 'none';
  gameEl.style.display = 'block';
  messageEl.textContent = '対戦相手が入室するのを待っています';
  renderControlsInRoom(); // 入室のたびに初期化
  // 盤面は startGame が来てから
});

socket.on('startGame', ({ yourTurn, yourColor }) => {
  roomsEl.style.display = 'none';
  gameEl.style.display = 'block';

  myTurn = !!yourTurn;
  myColor = yourColor;
  oppColor = (myColor === 'black') ? 'white' : 'black';

  initBoard();
  messageEl.textContent = myTurn ? 'あなたの番です' : '相手の番です';
  renderControlsInRoom(); // 入室/開戦時に毎回初期化
});

// サーバー正規の手通知（自分/相手ともにこのイベントで盤を更新）
socket.on('move', ({ x, y, color, nextTurn }) => {
  board[y][x] = color;
  renderBoard();
  myTurn = (nextTurn === myColor);
  awaitingAck = false;
  refreshInteractivity();
  messageEl.textContent = myTurn ? 'あなたの番です' : '相手の番です';
});

// 勝敗
socket.on('gameOver', ({ winnerColor, reason }) => {
  clearBoardUI();
  if (winnerColor === null) {
    messageEl.textContent = '引き分け';
  } else {
    messageEl.textContent = (winnerColor === myColor) ? 'あなたの勝ち！' : 'あなたの負け';
  }
  renderControlsPostGame(); // 再戦リクエスト & 退出
});

// 相手が再戦待機中（自分はまだ押していない）
socket.on('opponentRematchWaiting', () => {
  if (!/再戦/.test(messageEl.textContent)) {
    messageEl.textContent += (messageEl.textContent ? ' / ' : '') + '相手が再戦待機中';
  }
});

// 相手が退出（自動では戻さない）
socket.on('opponentLeft', () => {
  clearBoardUI();
  messageEl.textContent = '相手が退出しました';
  renderControlsBackToLobby();
});
</script>
</body>
</html>
