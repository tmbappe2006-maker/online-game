<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Car Soccer Online MVP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body { margin:0; height:100%; background:#111; overflow:hidden; }
    #hud {
      position:fixed; left:12px; top:10px;
      color:#fff; font:14px/1.4 sans-serif;
      z-index:10;
    }
  </style>
</head>
<body>
<div id="hud">接続中...</div>

<!-- Socket.IO -->
<script src="/socket.io/socket.io.js"></script>

<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
  import * as CANNON from 'https://cdn.skypack.dev/cannon-es';

  // ======== Three.js 基本設定 ========
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x101418);

  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, 10, 18);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  const light = new THREE.DirectionalLight(0xffffff, 1.2);
  light.position.set(10,20,10);
  scene.add(light, new THREE.AmbientLight(0xffffff, 0.25));

  const hud = document.getElementById('hud');

  // ======== フィールド ========
  const FIELD_W = 60, FIELD_L = 36;

  function wall(x,y,z,sx,sy,sz,c=0x20303a){
    const m = new THREE.Mesh(new THREE.BoxGeometry(sx,sy,sz),
      new THREE.MeshStandardMaterial({color:c}));
    m.position.set(x,y,z); scene.add(m);
    return m;
  }
  wall(0,-0.5,0, FIELD_W,1,FIELD_L, 0x1e2a33);
  wall(0,4,-FIELD_L/2, FIELD_W,8,1);
  wall(0,4, FIELD_L/2, FIELD_W,8,1);
  wall(-FIELD_W/2,4,0, 1,8,FIELD_L);
  wall( FIELD_W/2,4,0, 1,8,FIELD_L);

  const GOAL_W=14, GOAL_H=5, GOAL_D=2;
  const goalBlue = wall(0,GOAL_H/2,-FIELD_L/2+GOAL_D/2+0.5,GOAL_W,GOAL_H,GOAL_D,0x2244ff);
  goalBlue.material.transparent=true; goalBlue.material.opacity=0.15;
  const goalOrange = wall(0,GOAL_H/2,FIELD_L/2-GOAL_D/2-0.5,GOAL_W,GOAL_H,GOAL_D,0xff7a22);
  goalOrange.material.transparent=true; goalOrange.material.opacity=0.15;

  // ======== プレイヤー（自分） ========
  const carMesh = new THREE.Mesh(
    new THREE.BoxGeometry(2.2,1.0,3.2),
    new THREE.MeshStandardMaterial({color:0x66ccff})
  );
  scene.add(carMesh);

  // 物理設定（自分の車のみローカル）
  const world = new CANNON.World({ gravity: new CANNON.Vec3(0,-9.82,0) });
  const matGround = new CANNON.Material("ground");
  const matCar = new CANNON.Material("car");
  world.addContactMaterial(new CANNON.ContactMaterial(matGround, matCar, { friction:0.6, restitution:0 }));

  const ground = new CANNON.Body({ type: CANNON.Body.STATIC });
  ground.addShape(new CANNON.Box(new CANNON.Vec3(FIELD_W/2,0.5,FIELD_L/2)));
  ground.position.set(0,-0.5,0);
  world.addBody(ground);

  const carBody = new CANNON.Body({
    mass:1200, material:matCar,
    shape:new CANNON.Box(new CANNON.Vec3(1.1,0.5,1.6)),
    angularDamping:0.8, linearDamping:0.05
  });
  carBody.position.set(0,1.2,12);
  carBody.shapeOffsets[0].y -= 0.3;
  world.addBody(carBody);

  // ======== ボール（サーバ同期） ========
  const ballMesh = new THREE.Mesh(
    new THREE.SphereGeometry(1.2,24,16),
    new THREE.MeshStandardMaterial({color:0xffffff})
  );
  scene.add(ballMesh);
  let serverBall = { p:{x:0,y:2,z:0}, v:{x:0,y:0,z:0} };

  // ======== ネットワーク ========
  const socket = io(); // 同一オリジン
  let myId=null, myTeam="blue", score={blue:0,orange:0};

  const others = new Map(); // 他プレイヤー
  function getOrCreateOther(id,team){
    if(others.has(id)) return others.get(id);
    const color=(team==="blue")?0x3366ff:0xff9933;
    const m=new THREE.Mesh(new THREE.BoxGeometry(2.2,1.0,3.2),
      new THREE.MeshStandardMaterial({color}));
    scene.add(m);
    const o={mesh:m,last:{x:0,y:1.2,z:0,qy:0}};
    others.set(id,o); return o;
  }
  function removeOther(id){
    const o=others.get(id); if(!o)return;
    scene.remove(o.mesh); others.delete(id);
  }

  socket.on("hello", d=>{
    myId=d.id; myTeam=d.team; score=d.scores; serverBall=d.ball;
    hud.textContent=`Blue ${score.blue}:${score.orange} Orange （あなた:${myTeam}）`;
  });
  socket.on("players", list=>{
    const ids=new Set(Object.keys(list));
    for(const [id,p] of Object.entries(list)){
      if(id===myId)continue;
      const o=getOrCreateOther(id,p.team);
      o.last=p;
    }
    for(const id of Array.from(others.keys())){
      if(!ids.has(id))removeOther(id);
    }
  });
  socket.on("state", st=>{
    serverBall=st.ball;
    for(const [id,p] of Object.entries(st.players)){
      if(id===myId)continue;
      const o=getOrCreateOther(id,p.team);
      o.last=p;
    }
  });
  socket.on("score", s=>{
    score=s;
    hud.textContent=`Blue ${score.blue}:${score.orange} Orange （あなた:${myTeam}）`;
  });

  // 20Hzで自分の姿勢送信
  setInterval(()=>{
    const e=new THREE.Euler().setFromQuaternion(carMesh.quaternion,"YXZ");
    socket.emit("pose",{x:carMesh.position.x,y:carMesh.position.y,z:carMesh.position.z,qy:e.y});
  },50);

  // ======== 入力 ========
  const keys=new Set();
  addEventListener("keydown",e=>keys.add(e.code));
  addEventListener("keyup",e=>keys.delete(e.code));

  function followCamera(){
    const carPos=carMesh.position.clone();
    const back=new THREE.Vector3(0,0,-1).applyQuaternion(carMesh.quaternion).multiplyScalar(8);
    const up=new THREE.Vector3(0,4.5,0);
    const desired=carPos.clone().add(back).add(up);
    camera.position.lerp(desired,0.12);
    camera.lookAt(carPos.clone().add(new THREE.Vector3(0,1,0)));
  }

  // ======== メインループ ========
  const dt=1/60;
  function tick(){
    // 自分の車を動かす
    const fwd=new CANNON.Vec3(0,0,1);
    carBody.vectorToWorldFrame(fwd,fwd);
    const max=28, acc=8000, rev=6000, turn=300, jmp=6000, bst=12000;
    const vel=carBody.velocity.dot(fwd);
    const gnd=Math.abs(carBody.position.y-1.2)<0.3;

    if(keys.has("KeyW")||keys.has("ArrowUp"))   if(vel<max) carBody.applyForce(fwd.scale(acc*dt),carBody.position);
    if(keys.has("KeyS")||keys.has("ArrowDown")) if(vel>-max*0.5) carBody.applyForce(fwd.scale(-rev*dt),carBody.position);
    if(keys.has("KeyA")||keys.has("ArrowLeft"))  carBody.torque.y+=(gnd?turn:turn*0.4)*dt;
    if(keys.has("KeyD")||keys.has("ArrowRight")) carBody.torque.y-=(gnd?turn:turn*0.4)*dt;
    if(keys.has("Space")&&gnd) carBody.applyImpulse(new CANNON.Vec3(0,jmp*dt,0));
    if(keys.has("ShiftLeft")) carBody.applyForce(fwd.scale(bst*dt),carBody.position);

    world.step(dt);
    carMesh.position.copy(carBody.position);
    carMesh.quaternion.copy(carBody.quaternion);

    // 他プレイヤー補間
    for(const [id,o] of others){
      const t=o.last;
      o.mesh.position.lerp(new THREE.Vector3(t.x,t.y,t.z),0.25);
      const q=new THREE.Quaternion().setFromEuler(new THREE.Euler(0,t.qy,0));
      o.mesh.quaternion.slerp(q,0.25);
    }

    // サーバボール補間
    const tgt=new THREE.Vector3(serverBall.p.x,serverBall.p.y,serverBall.p.z);
    ballMesh.position.lerp(tgt,0.35);

    followCamera();
    renderer.render(scene,camera);
    requestAnimationFrame(tick);
  }

  addEventListener("resize",()=>{
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });

  tick();
</script>
</body>
</html>
